TODO
====

- Datentypen / Brick-Contents sind noch völlig undefiniert, das ist noch sehr unelite



Basic structure:
==============

- Index data
	- configuration parameter etc
	- List of timesteps consist of header data and index
	- Per timestep: List of bricks with Offset and brick size
- Timestep-data
	- File name can be generated directly from index
	- Padded volume data on cpu-pages(?), indexed by index file
	
	
Limitations:
================

- cubic volumes
- cubic bricks
	
	
Construction of index data:
======================

<ident><version><settings>\0<timestep_headers><bricklist>

<ident>
	"TUM3D_TIMEVOLUME" without Null terminations

<version>
	int32, version number

<settings>
	String Key-Value-Pairs saved as "[key]\t=\t[value]\0"
	
	Name				Type					Comment
	---------------------------------------------------------------------
	bricksize			int32				Default-page length per brick
	overlap				int32				Overlap included in brick size
	padding				int32				#Bytes, padded on all sizes
	volumesize			int32				Page length (seitlange) of the volumes
	timesteps			int32				Number of time steps 
	compression			string				"true" or "false" (Compression is used)
	channels			int32				number of  channels per element
	
	
<timestep_headers>
	Fixed number of TimestepHeader-Structures
	
	struct TimestepHeader
	{
		int32 index;			// # of timesteps, actulally redundant, but theoretically allows missing Timesteps etc
		int32 brickListOffset;	// Adresse of bricklist of the timesteps in the data index 
		int32 numBricks;		// Number of bricks in this timestep to theoretically enable "empty" bricks
	}
	
<bricklist>
	Fixed number of BrickDesc-Structures
	
	struct BrickDesc
	{
		int32 spatialIndex[3];	// x / y / z brickindex
		int64 dataOffset;		// Offset in the Timestep-data
		int64 bytesize;			// Data ussage of Bricks in Bytes
		int64 paddedBytesize;	// Size of the bricks incl. padding
		int32 bricksize[3];		// Size of bricks, may be different for Randbricks from the standard block size
		int64 channelSize[<channels>];	// size of the each channel; variable depending on the number of channels
	}

