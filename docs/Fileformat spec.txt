TODO
====

- Datentypen / Brick-Contents sind noch völlig undefiniert, das ist noch sehr unelite



Basisstruktur:
==============

- Indexdatei
	- Konfigurationsparameter etc
	- Liste an Timesteps bestehend aus Header-Daten und index
	- Pro Timestep: Liste aus Bricks mit Offset und Größe
- Timestep-Dateien
	- Dateiname direkt aus index erzeugbar
	- Gebrickte Volumendaten auf CPU-Pages gepadded, indiziert durch die indexdatei
	
	
Einschränkungen:
================

- Kubische Volumen
- Kubische Bricks
	
	
Aufbau der Indexdatei:
======================

<ident><version><settings>\0<timestep_headers><bricklist>

<ident>
	"TUM3D_TIMEVOLUME" ohne nullterminierung

<version>
	int32, Versionsnummer

<settings>
	String Key-Value-Pairs gespeichert als "[key]\t=\t[value]\0"
	
	Name				Typ					Kommentar
	---------------------------------------------------------------------
	bricksize			int32				Default-Seitenlänge pro brick
	overlap				int32				Overlap-Anteil enthalten in bricksize
	padding				int32				#Bytes, auf die alle Größen gepadded werden
	volumesize			int32				Seitenlänge des Volumens
	timesteps			int32				Anzahl der Zeitschritte
	compression			string				"true" oder "false" (Compression verwendet)
	channels			int32				Anzahl der Kanäle pro Element
	
	
<timestep_headers>
	Fixe Anzahl von TimestepHeader-Strukturen
	
	struct TimestepHeader
	{
		int32 index;			// # des timesteps, eigentlich redundant, ermöglicht aber theoretisch fehlende Timesteps etc
		int32 brickListOffset;	// Adresse der Brickliste dieses Timesteps in der Indexdatei
		int32 numBricks;		// Anzahl an Bricks in diesem Timestep, um theoretisch "leere" Bricks zu ermöglichen
	}
	
<bricklist>
	Fixe Anzahl von BrickDesc-Strukturen
	
	struct BrickDesc
	{
		int32 spatialIndex[3];	// x / y / z brickindex
		int64 dataOffset;		// Offset in der Timestep-Datei
		int64 bytesize;			// Nutzdatengröße des Bricks in Bytes
		int64 paddedBytesize;	// Größe des Bricks inkl. padding
		int32 bricksize[3];		// Größe des Bricks, kann sich für Randbricks evtl. von der Standard-Brickgröße unterscheiden
		int64 channelSize[<channels>];	// Größe der einzelnen Channel; variabel je nach Anzahl der Kanäle
	}

